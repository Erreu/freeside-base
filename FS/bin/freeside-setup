#!/usr/bin/perl -Tw

#to delay loading dbdef until we're ready
BEGIN { $FS::Schema::setup_hack = 1; }

use strict;
use vars qw($opt_u $opt_d $opt_v);
use Getopt::Std;
use FS::UID qw(adminsuidsetup datasrc checkeuid getsecrets);
use FS::CurrentUser;
use FS::Schema qw( dbdef_dist reload_dbdef );
use FS::Record;
#use FS::raddb;
use FS::Setup qw(create_initial_data);

die "Not running uid freeside!" unless checkeuid();

#my %attrib2db =
#  map { lc($FS::raddb::attrib{$_}) => $_ } keys %FS::raddb::attrib;

getopts("u:vd:");
#my $user = shift or die &usage;

getsecrets($opt_u); #$user);

#needs to match FS::Record
my($dbdef_file) = "%%%FREESIDE_CONF%%%/dbdef.". datasrc;

###

my $username_len = 32;

#print "\n\n", <<END, ":";
#Freeside tracks the RADIUS User-Name, check attribute Password and
#reply attribute Framed-IP-Address for each user.  You can specify additional
#check and reply attributes (or you can add them later with the
#fs-radius-add-check and fs-radius-add-reply programs).
#
#First enter any additional RADIUS check attributes you need to track for each 
#user, separated by whitespace.
#END
#my @check_attributes = map { $attrib2db{lc($_)} or die "unknown attribute $_"; }
#                         split(" ",&getvalue);
#
#print "\n\n", <<END, ":";
#Now enter any additional reply attributes you need to track for each user,
#separated by whitespace.
#END
#my @attributes = map { $attrib2db{lc($_)} or die "unknown attribute $_"; }
#                   split(" ",&getvalue);
#
#print "\n\n", <<END, ":";
#Do you wish to enable the tracking of a second, separate shipping/service
#address?
#END
#my $ship = &_yesno;
#
#sub getvalue {
#  my($x)=scalar(<STDIN>);
#  chop $x;
#  $x;
#}
#
#sub _yesno {
#  print " [y/N]:";
#  my $x = scalar(<STDIN>);
#  $x =~ /^y/i;
#}

#my @check_attributes = (); #add later
#my @attributes = (); #add later
#my $ship = $opt_s;

###
# create a dbdef object from the old data structure
###

my $dbdef = dbdef_dist(datasrc);

#important
$dbdef->save($dbdef_file);
&FS::Schema::reload_dbdef($dbdef_file);

###
# create 'em
###

$FS::CurrentUser::upgrade_hack = 1;
my $dbh = adminsuidsetup $opt_u; #$user;

#create tables
$|=1;

foreach my $statement ( $dbdef->sql($dbh) ) {
  $dbh->do( $statement )
    or die "CREATE error: ". $dbh->errstr. "\ndoing statement: $statement";
}

#now go back and reverse engineer the db
#so we pick up the correct column DEFAULTs for #oidless inserts
dbdef_create($dbh, $dbdef_file);
delete $FS::Schema::dbdef_cache{$dbdef_file}; #force an actual reload
reload_dbdef($dbdef_file);

create_initial_data('domain' => $opt_d);

warn "Freeside database initialized - commiting transaction\n" if $opt_v;

$dbh->commit or die $dbh->errstr;
$dbh->disconnect or die $dbh->errstr;

warn "Database initialization committed successfully\n" if $opt_v;

sub dbdef_create { # reverse engineer the schema from the DB and save to file
  my( $dbh, $file ) = @_;
  my $dbdef = new_native DBIx::DBSchema $dbh;
  $dbdef->save($file);
}

sub usage {
  die "Usage:\n  freeside-setup -d domain.name [ -v ]\n"
  # [ -u user ] for devel/multi-db installs
}

1;



#!/usr/bin/perl -Tw

#to delay loading dbdef until we're ready
BEGIN { $FS::Schema::setup_hack = 1; }

use strict;
use vars qw($opt_s);
use Getopt::Std;
use Locale::Country;
use Locale::SubCountry;
use FS::UID qw(adminsuidsetup datasrc checkeuid getsecrets);
use FS::Schema qw( dbdef_dist reload_dbdef );
use FS::Record;
use FS::cust_main_county;
#use FS::raddb;
use FS::part_bill_event;

die "Not running uid freeside!" unless checkeuid();

#my %attrib2db =
#  map { lc($FS::raddb::attrib{$_}) => $_ } keys %FS::raddb::attrib;

getopts("s");
my $user = shift or die &usage;
getsecrets($user);

#needs to match FS::Record
my($dbdef_file) = "/usr/local/etc/freeside/dbdef.". datasrc;

###

#print "\nEnter the maximum username length: ";
#my($username_len)=&getvalue;
my $username_len = 32; #usernamemax config file

#print "\n\n", <<END, ":";
#Freeside tracks the RADIUS User-Name, check attribute Password and
#reply attribute Framed-IP-Address for each user.  You can specify additional
#check and reply attributes (or you can add them later with the
#fs-radius-add-check and fs-radius-add-reply programs).
#
#First enter any additional RADIUS check attributes you need to track for each 
#user, separated by whitespace.
#END
#my @check_attributes = map { $attrib2db{lc($_)} or die "unknown attribute $_"; }
#                         split(" ",&getvalue);
#
#print "\n\n", <<END, ":";
#Now enter any additional reply attributes you need to track for each user,
#separated by whitespace.
#END
#my @attributes = map { $attrib2db{lc($_)} or die "unknown attribute $_"; }
#                   split(" ",&getvalue);
#
#print "\n\n", <<END, ":";
#Do you wish to enable the tracking of a second, separate shipping/service
#address?
#END
#my $ship = &_yesno;
#
#sub getvalue {
#  my($x)=scalar(<STDIN>);
#  chop $x;
#  $x;
#}
#
#sub _yesno {
#  print " [y/N]:";
#  my $x = scalar(<STDIN>);
#  $x =~ /^y/i;
#}

#my @check_attributes = (); #add later
#my @attributes = (); #add later
#my $ship = $opt_s;

###
# create a dbdef object from the old data structure
###

my $dbdef = dbdef_dist;

#important
$dbdef->save($dbdef_file);
&FS::Schema::reload_dbdef($dbdef_file);

###
# create 'em
###

my $dbh = adminsuidsetup $user;

#create tables
$|=1;

foreach my $statement ( $dbdef->sql($dbh) ) {
  $dbh->do( $statement )
    or die "CREATE error: ". $dbh->errstr. "\ndoing statement: $statement";
}

#now go back and reverse engineer the db
#so we pick up the correct column DEFAULTs for #oidless inserts
dbdef_create($dbh, $dbdef_file);
delete $FS::Schema::dbdef_cache{$dbdef_file}; #force an actual reload
reload_dbdef($dbdef_file);

#cust_main_county
foreach my $country ( sort map uc($_), all_country_codes ) {

  my $subcountry = eval { new Locale::SubCountry($country) };
  my @states = $subcountry ? $subcountry->all_codes : undef;

  if ( !scalar(@states) || ( scalar(@states) == 1 && !defined($states[0]) ) ) {

    my $cust_main_county = new FS::cust_main_county({
      'tax'   => 0,
      'country' => $country,
    });  
    my $error = $cust_main_county->insert;
    die $error if $error;

  } else {

    if ( $states[0] =~ /^(\d+|\w)$/ ) {
      @states = map $subcountry->full_name($_), @states
    }

    foreach my $state ( @states ) {

      my $cust_main_county = new FS::cust_main_county({
        'state' => $state,
        'tax'   => 0,
        'country' => $country,
      });  
      my $error = $cust_main_county->insert;
      die $error if $error;

    }
  
  }
}

#billing events
foreach my $aref ( 
  #[ 'COMP', 'Comp invoice', '$cust_bill->comp();', 30, 'comp' ],
  [ 'CARD', 'Batch card', '$cust_bill->batch_card();', 40, 'batch-card' ],
  [ 'BILL', 'Send invoice', '$cust_bill->send();', 50, 'send' ],
  [ 'DCRD', 'Send invoice', '$cust_bill->send();', 50, 'send' ],
  [ 'DCHK', 'Send invoice', '$cust_bill->send();', 50, 'send' ],
) {

  my $part_bill_event = new FS::part_bill_event({
    'payby' => $aref->[0],
    'event' => $aref->[1],
    'eventcode' => $aref->[2],
    'seconds' => 0,
    'weight' => $aref->[3],
    'plan' => $aref->[4],
  });
  my($error);
  $error=$part_bill_event->insert;
  die $error if $error;

}

$dbh->commit or die $dbh->errstr;
$dbh->disconnect or die $dbh->errstr;

#print "Freeside database initialized sucessfully\n";

sub dbdef_create { # reverse engineer the schema from the DB and save to file
  my( $dbh, $file ) = @_;
  my $dbdef = new_native DBIx::DBSchema $dbh;
  $dbdef->save($file);
}

sub usage {
  die "Usage:\n  freeside-setup user\n"; 
}

1;


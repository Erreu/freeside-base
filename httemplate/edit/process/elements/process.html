<%doc>

Example:

 include( 'elements/process.html',

   ###
   # required
   ###

  'table' => 'tablename',

   #? 'primary_key' => #required when the dbdef doesn't know...???
   #? 'fields' => []   #""

   ###
   # optional
   ###

   'viewall_dir'  => '', #'search' or 'browse', defaults to 'search'
   OR
   'redirect'     => 'view/table.cgi?', # value of primary key is appended
   OR
   'popup_reload' => 'Momentary success message', #will reload parent window

   'error_redirect' => popurl(2).'edit/table.cgi?', #query string appended

   'edit_ext' => 'html', #defaults to 'html', you might want 'cgi' while the
                         #naming is still inconsistent

   'copy_on_empty'  => [ 'old_field_name', 'another_old_field', ... ],

   'clear_on_error' => [ 'form_field1', 'form_field2', ... ],

   'process_m2m' => { 'link_table'   => 'link_table_name',
                      'target_table' => 'target_table_name',
                    },
   'process_m2name' => { 'link_table'   => 'link_table_name',
                         'link_static' => { 'column' => 'value' },
                         'num_col' => 'column', #if column name is different in
                                                #link_table than source_table 
                         'name_col' => 'name_column',
                         'names_list' => [ 'list', 'names' ],
                         
                         'param_style' => 'link_table.value checkboxes',
                         #or#
                         'param_style' => 'name_colN values',


                       },

   #supplies arguments to insert() and replace()
   # for use with tables that are FS::option_Common
   'args_callback' => sub { my( $cgi, $object ) = @_; },

   'debug' => 1, #turns on debugging output

   #agent virtualization
   'agent_virt'       => 1,
   'agent_null_right' => 'Access Right Name',

 )

</%doc>
%if ( $error ) {
%
%  my $edit_ext = $opt{'edit_ext'} || 'html';
%  my $url = $opt{'error_redirect'} || popurl(2)."$table.$edit_ext";
%  if ( length($cgi->query_string) > 1920 ) { #stupid IE 2083 URL limit
% 
%    my $session = int(rand(4294967296)); #XXX
%    my $pref = new FS::access_user_pref({
%      'usernum'    => $FS::CurrentUser::CurrentUser->usernum,
%      'prefname'   => "redirect$session",
%      'prefvalue'  => $cgi->query_string,
%      'expiration' => time + 3600, #1h?  1m?
%    });
%    my $pref_error = $pref->insert;
%    if ( $pref_error ) {
%      die "FATAL: couldn't even set redirect cookie: $pref_error".
%          " attempting to set redirect$session to ". $cgi->query_string."\n";
%    }
%
<% $cgi->redirect("$url?redirect=$session") %>
%
%  } else {
%
<% $cgi->redirect("$url?". $cgi->query_string ) %>
%
%  } 
%
% #different ways of handling success
%
%} elsif ( $opt{'popup_reload'} ) {

  <% include('/elements/header-popup.html', $opt{'popup_reload'} ) %>

  <SCRIPT TYPE="text/javascript">
    window.top.location.reload();
  </SCRIPT>

  </BODY>
  </HTML>

%} elsif ( $opt{'redirect'} ) {
%
<% $cgi->redirect( $opt{'redirect'}. $pkeyvalue ) %>
%
%} else { 
%
<% $cgi->redirect( popurl(3). ($opt{viewall_dir}||'search'). "/$table.html" ) %>
%}
<%once>

  my $me = 'process.html:';

</%once>
<%init>

my(%opt) = @_;

my $curuser = $FS::CurrentUser::CurrentUser;

#false laziness w/edit.html
my $table = $opt{'table'};
my $class = "FS::$table";
my $pkey = dbdef->table($table)->primary_key; #? $opt{'primary_key'} || 
my $fields = $opt{'fields'}
             #|| [ grep { $_ ne $pkey } dbdef->table($table)->columns ];
             || [ fields($table) ];

my $pkeyvalue = $cgi->param($pkey);

my $old = '';
if ( $pkeyvalue ) {
  $old = qsearchs({
    'table'   => $table,
    'hashref' => { $pkey => $pkeyvalue },
    'extra_sql' => ( $opt{'agent_virt'}
                       ? ' AND '. $curuser->agentnums_sql(
                                    'null_right' => $opt{'agent_null_right'}
                                  )
                       : ''
                   ),
  });
}

my %hash = map { $_ => scalar($cgi->param($_)) } @$fields;

my $new = $class->new( \%hash );

if ( $opt{'agent_virt'} ) {
  die "illegal agentnum"
    unless $curuser->agentnums_href->{$new->agentnum}
        or $opt{'agent_null_right'}
           && ! $new->agentnum
           && $curuser->access_right($opt{'agent_null_right'});
}

if ($old && exists($opt{'copy_on_empty'})) {
  foreach my $field (@{$opt{'copy_on_empty'}}) {
    $new->set($field, $old->get($field))
      unless scalar($cgi->param($field));
  }
}

my $error = $new->check;

my @args = ();
if ( !$error && $opt{'args_callback'} ) {
  @args = &{ $opt{'args_callback'} }( $cgi, $new );
}

if ( !$error && $opt{'debug'} ) {
  warn "$me updating record in $table table using $class class\n";
  warn Dumper(\%hash);
  warn "with args: \n". Dumper(\@args) if @args;
}

if ( !$error ) {
  if ( $pkeyvalue ) {
    $error = $new->replace($old, @args);
  } else {
    $error = $new->insert(@args);
    $pkeyvalue = $new->getfield($pkey);
  }
}

if ( !$error && $opt{'process_m2m'} ) {

  if ( $opt{'debug'} ) {
    warn "$me processing m2m:\n". Dumper( %{ $opt{'process_m2m'} },
                                          'params' => scalar($cgi->Vars),
                                        );
  }

  $error = $new->process_m2m( %{ $opt{'process_m2m'} },
                              'params' => scalar($cgi->Vars),
                            );
}

if ( !$error && $opt{'process_m2name'} ) {

  if ( $opt{'debug'} ) {
    warn "$me processing m2name:\n". Dumper( %{ $opt{'process_m2name'} },
                                             'params' => scalar($cgi->Vars),
                                           );
  }

  $error = $new->process_m2name( %{ $opt{'process_m2name'} },
                                 'params' => scalar($cgi->Vars),
                               );
}


if ( $error ) {
  $cgi->param('error', $error);
  if ( $opt{'clear_on_error'} && scalar(@{$opt{'clear_on_error'}}) ) {
    foreach my $field (@{$opt{'clear_on_error'}}) {
      $cgi->param($field, '')
    }
  }
}

</%init>

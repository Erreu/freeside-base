%
%
%  # options example...
%  # 
%  ###
%  ##req
%  ##
%  #
%  # 'table' => 
%  #
%  # #? 'primary_key' => #required when the dbdef doesn't know...???
%  # #? 'fields' => []
%  #
%  ###
%  ##opt
%  ###
%  #
%  # 'viewall_dir' => '', #'search' or 'browse', defaults to 'search'
%  # OR
%  # 'redirect'    => 'view/table.cgi?', # value of primary key is appended
%  #
%  # 'error_redirect' => popurl(2).'edit/table.cgi?', #query string appended
%  #
%  # 'edit_ext' => 'html', #defaults to 'html', you might want 'cgi' while the
%  #                       #naming is still inconsistent
%  # 
%  # 'copy_on_empty'  => [ 'old_field_name', 'another_old_field', ... ],
%  # 
%  # 'clear_on_error' => [ 'form_field1', 'form_field2', ... ],
%  # 
%  # 'process_m2m' => { 'link_table'   => 'link_table_name',
%  #                    'target_table' => 'target_table_name',
%  #                  },
%  # 'process_m2name' => { 'link_table'   => 'link_table_name',
%  #                       'link_static' => { 'column' => 'value' },
%  #                       'num_col' => 'column', #if column name is different in
%  #                                              #link_table than source_table 
%  #                       'name_col' => 'name_column',
%  #                       'names_list' => [ 'list', 'names' ],
%  #                     },
%
%  my(%opt) = @_;
%
%  #false laziness w/edit.html
%  my $table = $opt{'table'};
%  my $class = "FS::$table";
%  my $pkey = dbdef->table($table)->primary_key; #? $opt{'primary_key'} || 
%  my $fields = $opt{'fields'}
%               #|| [ grep { $_ ne $pkey } dbdef->table($table)->columns ];
%               || [ fields($table) ];
%
%  my $pkeyvalue = $cgi->param($pkey);
%
%  my $old = qsearchs( $table, { $pkey => $pkeyvalue } ) if $pkeyvalue;
%
%  my $new = $class->new( {
%    map {
%      $_, scalar($cgi->param($_));
%    } @$fields
%  } );
%
%  if ($old && exists($opt{'copy_on_empty'})) {
%    foreach my $field (@{$opt{'copy_on_empty'}}) {
%      $new->set($field, $old->get($field))
%        unless scalar($cgi->param($field));
%    }
%  }
%
%  my $error;
%  if ( $pkeyvalue ) {
%    $error = $new->replace($old);
%  } else {
%    $error = $new->insert;
%    $pkeyvalue = $new->getfield($pkey);
%  }
%
%  if ( !$error && $opt{'process_m2m'} ) {
%    $error = $new->process_m2m( %{ $opt{'process_m2m'} },
%                                'params' => scalar($cgi->Vars),
%                              );
%  }
%
%  if ( !$error && $opt{'process_m2name'} ) {
%    $error = $new->process_m2name( %{ $opt{'process_m2name'} },
%                                   'params' => scalar($cgi->Vars),
%                                 );
%  }
%
%  # XXX print?!?!
%
%  if ( $error ) {
%    $cgi->param('error', $error);
%    if (scalar(@{$opt{'clear_on_error'}})) {
%      foreach my $field (@{$opt{'clear_on_error'}}) {
%        $cgi->param($field, '')
%      }
%    }
%    my $edit_ext = $opt{'edit_ext'} || 'html';
%    my $url = $opt{'error_redirect'} || popurl(2)."$table.$edit_ext?";
%    print $cgi->redirect($url. $cgi->query_string );
%  } elsif ( $opt{'redirect'} ) {
%    print $cgi->redirect( $opt{'redirect'}. $pkeyvalue );
%  } else { 
%    print $cgi->redirect( popurl(3).
%                          ( $opt{'viewall_dir'} || 'search' ).
%                          "/$table.html"
%                        );
%  }
%
%

